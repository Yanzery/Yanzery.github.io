<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript基础（二）作用域]]></title>
    <url>%2F2019%2F01%2F14%2FJavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一、何为作用域？ 如我们所知的，JavaScript 的函数是一个对象，那么既然是一个对象，就会有属性，然而对象中有一些属性我们可以访问有一些却是我们访问不了的，访问不了的那些是JavaScript引擎存取的，那么我们的作用域[[scope]]就是其中一个。作用域[[scope]]存储了运行期上下文的集合。 那么问题又来了，执行期上下文又是什么呢，就是当函数执行时，会创建一个称为执行期上下文的内部对象，一个执行上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文是独一无二的，并且当函数执行结束时，它所产生的执行期上下文会被销毁。 接着说到作用域，那也要说一下作用域链，作用域[[scope]]中存储的执行期上下文对象的集合呈链式链接，所以叫作用域链。 那么我们查找变量就是从函数作用域链的顶端依次向下查找二、结合例子讲解 1234567891011121314function a () &#123; var aa = 2; function b () &#123; var aa = 3; function c () &#123; &#125; c(); &#125; b(); console.log(aa);&#125;a(); 首先 a函数被 defined，所以自然就产生了它的属性[[scope]],[[scope]]里面存的是作用域链，作用域链自然就是对象的集合，所以此时a在被定义时的作用域链就是此时的所处的执行期上下文，那么这个环境就是全局对象，因此我们的作用域链中仅有一位[0]位– global object（下面简称GO）【因为函数a刚在全局中被定义，那它的执行期上下文自然只有一个全局的对象】具体可看图一： 接着就是a函数执行，a函数执行，一个函数执行必然产生一个函数独一无二的执行期上下文即产生属于a的AO（acitive object），那么这个AO就是放在作用域链的最顶端（任何环境的作用域链的最顶端一定是该环境下的AO）。所以把AO放在顶端【0】位，那么原来的在第一位的GO就放在第二位，作用域链如图二所示： 在a函数执行的中，b被定义，因此b的作用域就是此时所处的环境的执行上下文，即函数a的作用域链，即图二所示； 接着b执行，产生自己的执行期上下文，b的AO放在作用域的最顶端，所以此刻b的作用域链即首位[0]–b的AO+b被定义时所处的环境，如图三所示： 再接着c被定义(同理)，c被执行（也同理） 最后打印出来的aa的值为3；因为b函数执行的作用域链中a的AO跟原本a函数执行的AO是同一个； 当函数执行结束时，其执行期上下文会被立即销毁，例如b执行完后，那么b的AO会被销毁，但由于a函数还没执行结束，所以a的AO还继续存在。 当再次调用函数a时，将产生新的作用域链，与之前的是否调用执行没有关系。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础（一）预编译]]></title>
    <url>%2F2019%2F01%2F13%2FJavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E9%A2%84%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[JavaScript（一）预编译1. 关于JavaScript众所周知 JavaScript 是一门脚本语言，为了缩短传统的“编写、编译、链接、运行”过程而创建的计算机编程语言。一个脚本是通常是解释运行而非编译，因此 JavaScript 也是一门解释性语言，即解释一行执行一行。 JavaScript执行的三部曲 语法分析 预编译 解释执行 语法分析：即先通篇检查有没有语法错误，若出现语法错误，即该模块无法执行； 解释执行：即执行代码； 预编译： 可以理解为在函数执行前在内存空间开辟一些空间，存放一些变量和函数；理解了预编译能够加深对作用域的理解； 2. 预编译2.1 预编译的前奏 imply global 暗示全局变量：即任何变量，如果变量未经声明，就赋值，此变量就为全局对象所有。 12a = 123；var a = b = 123； // b未经声明就被赋值为123； 一切声明的全局变量，全是 window 的属性； window就是全局的域 2.2 预编译的四个步骤 创建 AO （Activation Object 即执行期上下文） 对象； 找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined； 将实参值和形参统一； 在函数体里面找函数声明，值赋予函数体；例如： 12345678910111213141516function fn (a) &#123; console.log(a);//a1 var a = 123; console.log(a);//a2 function a () &#123;&#125;//函数声明 console.log(a)//a3 var b = function () &#123;&#125;//函数表达式 console.log(b) function d () &#123;&#125; &#125; fn(1) 解析如下：1. 预编译过程： 创建 AO 对象 找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined； 1234AO&#123; a : undefined， b : undefined，&#125; 将实参和形参相统一 1234AO&#123; a : 1, b : undefined，&#125; 在函数体里面找函数声明，值赋予函数体； 12345AO&#123; a : function a () &#123;&#125;, b : undefined, d : function d () &#123;&#125;,&#125; 执行函数 2. 执行函数 首先打印a，在AO对象中寻找a，所以a1为function a () {} 执行 var a = 123；不完全执行，因为在步骤二中找变量声明，已经把变量提升了，但是a = 123；还没读，所以继续在 AO 对象中寻找属性名 a ，并执行 a = 123，将 a 的值 赋值为123；AO变为： 1234AO&#123; a : 123, ....&#125; 因此打印出来的 a，即 a2 为 123； 函数声明已经变量提升了；a3为123； 执行 1b = function () &#123;&#125; ,所以 b 为function () {}]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之变量的解构和解析]]></title>
    <url>%2F2018%2F10%2F24%2FES6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E5%92%8C%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、数组的解构赋值 基本用法按照一定的模式，从数组和对象中提取值，对变量进行赋值。 1let [a,b,c] = [1,2,2]; 如果解构不成功就是 undefine，如下就是解构不成功的； 12let [a] =[];let [a,b] = [2]; 如果等号右边不是数组将会报错，如下： 12let [a] = 1;let [a] = null; 2、对象的解构赋值数组的元素是按次序排列的，变量的取值是由他的位置决定的；而对象的属性是没有次序的，变量名必须与属性同名才能取到正确值。解构也可以用于嵌套解构的对象。 1let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 如果解构失败，变量的值等于 undefined。 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错 3、字符串的解构赋值1const [a, b, c, d, e] = &apos;hello&apos;; 4、函数参数的解构赋值12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 1[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); 5、用途（1）交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; （2）从函数返回多个值12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义方便将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] （5）遍历 Map 结构任何部署了 Iterator 接口的对象，都可以用 for … of 循环遍历。Map结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值很方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world （6）输入模块的指定方法加载模块时，往往需要指定输入哪些方法，解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 备注：阮一峰老师《ESMAScript 6 入门》学习笔记，很多详细内容请参考：http://es6.ruanyifeng.com/#docs/destructuring]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之let和const命令总结]]></title>
    <url>%2F2018%2F10%2F23%2FES6%E4%B9%8Blet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、 let 命令 1.1基本用法用来声明变量，但是声明的变量只在 let 命令所在的的代码块内有效。 for 循环的计数器，很适合用 let 命令。 for 循环设置循环变量的那部分是一个父作用域，而循环内部是一个单独的子作用域 1.2不存在变量提升var 命令会发生变量提升，变量可以在声明之前使用，值为 undefine1.3暂时性死区只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和使用该变量。1.4不允许重复声明let不允许在相同作用域内重复声明同一个变量。因此不能再函数内部重新声明参数。2、块级作用域 ==全局作用域和函数作用域下== 变量提升，内层变量可能覆盖外层变量。 用来计数的循环变量泄漏为全局变量。 ==ES6== 外层代码块不受内层代码块的影响。 允许块级作用域的任意嵌套，外层作用域无法读取内层作用域的变量。 内层作用域可以定义外层作用域的同名变量。 ==块级作用域与函数声明== 允许在块级作用域之中声明函数。块级作用域之中，函数声明语句的行为类似 let ，在块级作用域之外不可引见。但是幻术声明类似 var ，即会提升到全局作用域或函数作用域的头部，还会提升到所在的块级作用域的头部。 避免在块级作用域内声明函数，如果需要应该写成函数表达式，而不是含税声明语句。3、const 命令3.1 基本用法 const 声明一个只读的常量 只声明不赋值会报错。只在声明所在的块级作用域有效，存在暂时性死区，只能自声明的位置后使用。 不可重复使用。 const是指变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值）值就保存在变量所指向的那个内存地址；而对于复合型的数据（对象和数组），变量指向的内存地址保存的只是一个指针。const只能保证这个指针是固定的。]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript中函数的总结]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[函数的定义1.直接定义1234567function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 函数内部的语句在执行是，一旦执行到return时就执行完毕并将结果返回。如果没有return语句，函数执行完毕后也会返回结果，只是结果是undefined。 由于函数是一个对象，所以函数名可以视为指向该函数的变量。函数名可以保存在变量，对象，数组中。 函数还可以被当做参数传递给其他函数，函数也可以返回函数，函数拥有方法。 2.声明式定义1234567var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 将匿名函数赋值给了变量，通过变量可以调用该函数。 函数的调用调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明的参数，函数还接收两个参数this和arguments。【this的值取决于函数的调用模式】 函数的调用模式 方法调用 函数调用 构造器调用 apply调用 1.方法调用模式当函数保存为对象的一个属性时，称为方法，当方法被调用是，this绑定到该对象。该方法可以用this来访问自己所属的对象，所以能从对象中取值或对对象进行修改。通过this取得他们所属对象的上下文的方法称为公共方法。 2.函数模式的调用当函数不是一个对象的属性时就是被当做一个函数来调用，this被绑定到全局。解决方案：在函数内把this赋值给变量that 3.构造器模式如果函数前面带上new调用，会创建一个连接到该函数prototype成员的新对象，this会被绑定到这个新对象上 4.Apply调用apply构建一个参数数组传递给调用函数，apply方法接收两个参数，第一个是绑定this的值，第二个是参数数组，可以自己选择this的值 调用函数时，按顺序传入参数即可，由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有关系，虽然函数内部并不需要这些参数；传入的参数比定义的少也没有问题，但由于收到的参数为undefined，计算结果为NaN，要避免收到undefined，可以对参数进行检查。 argumentsarguments只在函数内部起作用，并且永远执行当前函数的调用者传入的所有参数，类似Array，拥有length属性。 返回当函数结束时，会把控制权交给调用该函数的程序。return语句使函数提前返回，当return被执行时，函数立即返回而不再执行余下的语句。一个函数总会返回一个值，如果没有就默认返回undefined。如果函数调用是在前面加上new，且返回值不是一个对象，则返回this 异常利用arguments可以获得调用者传入的所有参数，即使函数不定义参数，也可以拿到参数的值；而实际上arguments最常用语判断传入参数的个数 rest参数]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域的理解和解决方案总结]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[何为跨域？首先，我们得先理解一下何为跨域？所谓跨域，即网站的协议名 protocol（例如 http ://） 、域名 host （例如：www.example.com）、端口号 port (例如 80 ，默认端口可以省略) 这三个中的任意一个不同，网站之间的数据传输或者请求就属于跨域请求了。 这是由于浏览器的同源策略，为了防范跨站脚本的攻击，禁止客户端脚本对不同域的服务进行跨站调用，但是跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但返回结果被浏览器拦截了。有些浏览器不允许从HTTPS协议的域 跨域访问 HTTP协议，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。如果是非同源，共有三种行为受到限制：（1）cookie、LocalStorage 和 IndexDB 无法读取；（2）DOM 无法获得；（3）AJAX请求不能发送。【这里再解释一下同源（具体定义可以查看 MDN），如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。IE 有例外，一是授信范围：两个相互之间高度互信的域名，不遵守同源策略的限制；二是端口：IE 未将端口号加入到同源策略的组成成分中。更多有关源的介绍可以查看 MDN ：https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy】 如何去解决？ 接着，既然我们知道了何为跨域，跨越有时候在实际的开发中有时候又无法避免，下面介绍几种常见的跨域方法： 1、利用 JSONP 实现跨域JSONP （JSON with Padding）是 JSON 的一种“使用模式”。利用 JSON 实现跨域的原理是：HTML 的 script 标签是不受同源策略的限制的，可以通过 script 标签加载并执行其他的域的 js 文件的。 例如通过 jQery 封装的方法可以很方便地进行 JSONP 的操作： 12345678910111213141516171819$.ajax(&#123; type: &apos;GET&apos;, url: &apos;http://jjjjjjjj.com/data&apos;, // 需要提交给服务端的数据: data: &#123; name: &apos;燕子&apos; &#125;, // 指定数据类型: dataType: &apos;jsonp&apos;, timeout: 300, success: function(data)&#123; this.append(data.project.html) &#125;, error: function(xhr, type)&#123; alert(&apos;数据获取失败！&apos;) &#125;&#125;)//使用$.getJSON$.getJSON(&apos;http://jjjjjjjj.com/data?callback=?,function(data)&apos;)&#123; //处理获得的json数据&#125;); 总结：JSONP 的兼容性好，在更古老的浏览器都可以运行，不需要 XMLHTTPRequest 或 ActiveX 的支持，并且在请求完毕后可以通过调用 callback 的方式回传结果；然而缺点是，它只支持 GET 请求 而不支持 POST 等其他类型的 HTTP 请求；还有 只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面的之间 JavaScript 调用的问题； 2、利用 CORS 实现跨域CORS （Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的思想是使用自定义的 HTTP 头部，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源，从而决定请求或响应是应该成功还是失败，CORS 本身并非绝对的安全，可利用 OAuth2 加强保障。（更多关于 CORS 的详解可以查看 阮一峰老师的一篇文章：跨域资源共享 CORS 详解） 1header(&quot;Access-Control-Allow-Origin: *&quot;) //“*”号表示允许任何域向我们的服务端提交请求 1header(&quot;Access-Control-Allow-Origin: http://jjjjj.jd.com&quot;) //也可以设置指定的域名 与 JSONP 相比，CORS 更为先进、方便： CORS 支持所有类型的 HTTP 请求； 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理； 绝大多数现代浏览器都已经支持了CORS； 3、window.name当window 的 loaction 变化时，页面重新加载，它的 name 属性可以依然保持不变。每个页面的对 window.name 都有读写权限，window.name 是持久存在一个窗口载入过所有页面中的。 我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。 4、document.domain 跨域（只适用于不同子域的框架间的交互）同源策略不能用 ajax 方法去请求不同源的文档，还有一个限制就是浏览器不同域的框架之间不能进行 JS 的交互操作的，不同的框架可以获取 window 对象，但无法获取相应的属性和方法。 这个时候，我们可以通过把两个页面的 document.domain 都设成相同的域名就可以，不过 window.domain 的设置也是有限制的，只能把 window.domain 设置成自身或更高一级的父域，且主域必须相同 5、HTML5 的 postMessage 方法高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。 window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（例如：在该方法之后设置的事件、之前设置的timeout 事件）向目标窗口派发一个 MessageEvent 消息。 该 MessageEvent 消息有四个属性需要注意： message 属性表示该 message 的类型； data 属性为 window.postMessage 的第一个参数；origin 属性表示调用 window.postMessage() 方法时调用页面的当前状态； source 属性记录调用 window.postMessage() 方法的窗口信息。 详细语法可参考 MDN 文档：window.postMessage]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《谁动了我的奶酪》]]></title>
    <url>%2F2018%2F10%2F19%2F%E3%80%8A%E8%B0%81%E5%8A%A8%E4%BA%86%E6%88%91%E7%9A%84%E5%A5%B6%E9%85%AA%E3%80%8B%2F</url>
    <content type="text"><![CDATA[这是2018年读的第一本书，这本书并不厚，讲的是一个简单的小故事，其中的道理更是非常地浅显易懂，道理大家都是懂的，关键是在于能否对道理深刻理解，我觉得人们所说的经验其实就是对这些简单道理的自己的深刻理解，并且只有自己经历才能真正的感受到它的作用。 这篇故事的大概是讲有两只老鼠和两个小矮人哼哼、唧唧住在迷宫中，他们以寻找迷宫里的奶酪为食物，迷宫的一些角落中往往都会藏着奶酪，那便是他们的赖以生存的食物。小老鼠的头脑比较简单，小矮人们总是认为自己比小老鼠们聪明，小老鼠就知道埋头找奶酪而已，并不会思考也不会寻找捷径。每天早上他们都会准备好装备从家里出发，一头钻进迷宫中寻找奶酪，就这样一天重复着一天，直到有一天，他们同时在迷宫的一个角落中找到了一大堆奶酪，特别特别地多特别特别地美味，他们都高兴极了，便开始习惯了每天早上不再去寻找，只要去到一个熟悉的地方就可以尽情地享受到美味，这样的日复一日，直到最后奶酪其实慢慢地变味了也变得很少了，当小老鼠发现这一切时，他们简单地只有一个想法——那就是继续去别的地方寻找可以吃的奶酪；而对于自认为头脑聪明的小矮人，他们就难以接受这个现实，他们已经习惯了不再寻找就有美味存在，他们坚信那里还有奶酪的，所以他们一直等待着，而小老鼠还是像以前一样每天都继续去寻找新的奶酪。 哼哼唧唧他们每天都去之前的地方痛苦的等待着，然而什么都没有，知道有一天唧唧想起以前每天都要去寻找奶酪，但是每天都还是可以填饱肚子的，所以他决定去试一下像以前那样子去寻找奶酪，而固执的哼哼还是想要在原地等待，他不相信奶酪会这样没了。而奔跑起来的唧唧渐渐地还是像以前一样能填饱肚子，然而哼哼仍然在原地，唧唧曾鼓励过哼哼，哼哼也慢慢地动起身来，但是他还是不相信，最后哼哼能否找到奶酪是留白的。 故事的内容基本就是以上吧，是以童话的形式呈现，虽然有点夸张，似于艺术来源于生活却又高于生活一样。书中的道理可以归结为以下： 变化总是会发生，你唯有可以做到的就是拥抱变化； 奶酪是会一点一点减少直到没有的，所以要时刻做好失去奶酪的准备； 经常嗅一嗅奶酪，这样你才会知道它是否依旧新鲜； 迅速适应变化，越快放弃变质的奶酪，你就越早享用新鲜的奶酪； 享受变化，享受探险的过程和新奶酪的美味。 书里只是反应了一定的现实。就像作者所说的那样“本书最有价值的不是故事本身，而是大家对它的理解与应用”。正所谓一千个读者就有一千个哈姆雷特，谁又能想到此书还曾经治愈过一个曾经情绪极为不稳定的少女。其实一本书、一句话只是一个契机，引发你去思考，真正做决定的依然是你的大脑。]]></content>
      <tags>
        <tag>书评</tag>
      </tags>
  </entry>
</search>
