<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React学习笔记-Redux]]></title>
    <url>%2F2019%2F06%2F09%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Redux%2F</url>
    <content type="text"><![CDATA[Redux首先，先双手献上经典的 Redux Flow图然后我们再娓娓道来~ React主要就是用来实现UI界面的，是一个专注于view层的框架。对于一些小项目，如果数据的交互不是很多，完全可以只使用React就能很好的实现。但是如果比较复杂，只使用React的state来存储状态就容易造成数据的冗余和重复，于是我们可以用Redux来帮忙。Redux是一种架构模式，是由flux发展而来的 Redux三大原则 唯一数据源 状态只读 数据改变只能通过纯函数（reducer）完成 接着：我们来解读一下那个Redux Flow图 基本的概念StoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore(reducer， defaultState)这个函数来生成 Store，生成三个方法getState(),dispatch(),subscrible()。 getState()：存储的数据，状态树；当前时刻的 State，可以通过store.getState()拿到。 dispatch(action)：分发action，并返回一个action，这是唯一能改变store中数据的方式； subscrible(listener)：注册一个监听者，store发生变化的时候被调用。 ActionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。Action是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置。Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 store.dispatch()View通过store.dispatch()发出action，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 reducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。但是 Store 只是一个“仓库”，它不晓得给什么数据到 View，所以只能交给 reducer，这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State，reducer(previousState,action) 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 总结 首先，用户发出 Action； 1store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。 1let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数。 12// 设置监听函数store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 参考【非常感谢！】：阮一峰redux入门教程对React、Redux、React-Redux详细剖析]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RReact学习笔记-组件的数据]]></title>
    <url>%2F2019%2F06%2F09%2FRReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[组件的数据prop&amp;state引入React组件的数据分为两种：prop和state，无论是prop还是state的改变都可能会引发组件的重新渲染，因此选择显得尤为重要。那么其实大体的原则也很简单，prop是组件对外的接口，state是组件内部的状态，即对外用prop对内用state。 prop什么是prop在 React中文文档官网的解释是：当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。但是，我总感觉这个有点拗口，prop就是从外部传递给组件的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。组件之间通过prop来传递数据。 给prop赋值例子： 1234&lt;SampleButton id = "simple" borderWidth = &#123;2&#125; onClick = &#123;onButtonClick&#125; style = &#123;&#123;color:"red"&#125;&#125;/&gt; 在上面的例子中，创建了名为SampleButton的组件实例，使用了名字分别为id、border Width、onClick和style的prop,React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。 注意：当prop的类型不是字符串类型时，在JSX中必须用花括号{}把prop值包住，所以style的值有两层花括号，外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量。 当外部世界要传递一些数据给React组件，一个最直接的方式就是通过prop；同样，React组件要反馈数据给外部世界，也可以用prop，因为prop的类型不限于纯数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件在恰当的实际调用函数类型的prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。 读取prop值12345678910class Counter extends Component &#123; constructor(props) &#123; super(props); &#125; this.state = &#123; count: props.initValue || 0 &#125;&#125; 子组件通过在构造函数中调用super（props），那么组件实例被构造之后，类实例的所有成员函数就可以通过this.props访问到父组件传递过来的props值。很明显，给this.props赋值是React.Component构造函数的工作之一。 在构造函数中可以通过参数props获得传入prop值，在组件内部是通过其他函数中则可以通过this.props访问传入prop的值， 1const &#123;caption&#125; = this.props; props 不可变props 一旦传入进来就不能改变。组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。所有 React组件都必须像纯函数一样保护它们的 props 不被更改。 但是应用程序的 UI 是动态的，并会伴随着时间的推移而变化，那怎么ban？不急，有state。 stateState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state。 初始化state通常在组件类的构造函数结尾处初始化state，通过对this.state的赋值完成了对组件state的初始化 123456constructor(props) &#123; ... this.state = &#123; count: props.initValue || 0 &#125;&#125; 组件的state必须是一个JavaScript对象，不能是string或者number这样的简单数据类型，即使我们需要存储的只是一个数字类型的数据，也只能把它某个字段对应的值。 读取和更新state通过this.state可以读取到组件的当前state。但是，改变组件state必须要使用this.setState函数，而不能直接去修改this.state。 直接修改this.state的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应this.state值的变化；而this.setState（）函数所做的事情，首先是改变this.state的值，然后驱动组件经历更新过程，这样才有机会让this.state里新的值出现在界面。 this.setState（）接受一个对象或者函数作为参数。 对象传入一个对象的时候，这个对象表示该组件的新状态。但你只需要传入需要更新的部分就可以了，而不需要传入整个对象。12// Correctthis.setState(&#123;comment: 'Hello'&#125;); 函数State 的更新可能是异步的出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。当你调用 setState 的时候，React.js 并不会马上修改state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新 这里就自然地引出了 setState的第二种使用方式，可以接受一个函数作为参数。React.js 会把上一个 setState的结果传入这个函数，这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象： 1234// Correctthis.setState((state, props) =&gt; (&#123; counter: state.counter + props.increment&#125;)); props VS state props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。 state 的主要作用是用于组件保存、控制、修改自己的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState 方法进行更新，setState 会导致组件的重新渲染。 参考：【非常感谢！】 react官方中文文档 react.js小书 深入浅出React和Redux]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记-JSX]]></title>
    <url>%2F2019%2F06%2F09%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JSX%2F</url>
    <content type="text"><![CDATA[React学习笔记-JSX引入首先，先来看一段非常简单的代码：1234567891011121314151617import React, &#123; Component &#125; from 'react'import ReactDOM from 'react-dom'class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h1&gt;React 笔记&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Header /&gt;, document.getElementById('root')) 还有这个： 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 一开始看完我是感觉有点奇怪的，这么粗暴地直接在 js 上直接嵌入 HTML 吗？好的，事实证明我这么简单粗暴的看法也是错的，这其实是一种JavaScript 的语法扩展，称为 JSX，这确实很容易让人联想到模板语言，但是它具有JavaScript的全部功能。那么接下来就来看看JSX的原理。 JSX 原理事实上：所谓的 JSX 其实就是 JavaScript 对象。我们可以思考类似上面的那段 JSX 用JavaScript对象应该怎么表示： 1234&lt;div class=&apos;box&apos; id=&apos;content&apos;&gt; &lt;div class=&apos;title&apos;&gt;Hello&lt;/div&gt; &lt;button&gt;Click&lt;/button&gt;&lt;/div&gt; 所有的信息我们都可以用合法的 JavaScript 对象来表示： 12345678910111213141516&#123; tag: 'div', attrs: &#123; className: 'box', id: 'content'&#125;, children: [ &#123; tag: 'div', arrts: &#123; className: 'title' &#125;, children: ['Hello'] &#125;, &#123; tag: 'button', attrs: null, children: ['Click'] &#125; ]&#125; 嘻嘻嘻，，发现了没有，HTML 的信息和 JavaScript 所包含的结构和信息其实是一样的，我们可以用 JavaScript 对象来描述所有能用 HTML 表示的 UI 信息。但是用 JavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了。 因此，把JavaScript 的语法扩展一下，让JavaScript语言能支持编写类似HTML标签结构的语法，这样会方便很多，在编译过程会把JSX结构转换成JavaScript的对象结构。可以总结一下从JSX到页面经过什么样的过程： 那么问题又来啦，为什么不直接把JSX直接渲染成构造DOM结构呢，而要经过中间那一层呢？ 第一个原因是：我们拿到的这个表示UI的结构和信息的对象后不一定会把元素直接渲染到浏览器的普通页面上，例如我们转换成原生的APP（React Native可以开发原生APP）； 第二个原因是：我们都知道直接操作DOM的开销太大了，太频繁地操作DOM势必会影响性能，那么如果有一个JavaScript对象后，当数据变化时或者需要更新组件是，就可以用比较快的算法操作js对象而不是直接页面的DOM，尽量少的减少浏览器重排，极大地优化性能。 JSX的使用在 JSX 中嵌入表达式 在JSX中使用变量，需要用大括号将其包裹起来： 12const name = 'Yanzery';const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;; 可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName。 JSX 也是一个表达式。例如，可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX。 使用 JSX 指定子元素。假如一个标签里面没有内容，你可以使用 /&gt; 来闭合标签，就像 XML 语法一样；同时JSX 标签里能够包含很多子元素: 12345678const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); 另外哦：可以安全地在 JSX 当中插入用户输入内容，因为React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。 在JSX元素中直接添加事件绑定在HTML中直接书写onclick一直就是为人诟病的写法，网页应用开发界一直倡导的是用jQuery的方法添加事件处理函数，直接写onclick会带来代码混乱的问题。但是！，不得不承认直接添加事件绑定实在是太方便啦~ 那么你发现没有，在JSX中同样也可以通过onClick这样的方式给一个元素添加一个事件处理函数，这是时代倒退了还是进步了呢？实际上呢，JSX的onClick事件处理方式和HTML的onclick有很大不同的哦！ 即使现在，我们还是要说在HTML中直接使用onclick很不专业，原因如下： onclick添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果； 给很多DOM元素添加onclick事件，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低； 对于使用onclick的DOM元素，如果要动态地从DOM树中删掉的话，需要把对应的时间处理器注销，假如忘了注销，就可能造成内存泄露，这样的bug很难被发现。 然而在上面说的这些问题，在JSX中都不存在。 onClick挂载的每个函数，都可以控制在组件范围内，不会污染全局空间。 onClick，实际上是使用了事件委托的方式处理点击事件，无论有多少个onClick出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定函数，使用事件委托的性能当然要比为每个onClick都挂载一个事件处理函数要高。 React控制了组件的生命周期，在unmount的时候自然能够清除相关的所有事件处理函数，内存泄露也不再是一个问题。 React的组件可以把JavaScript、HTML和CSS的功能在一个文件中，实现真正的组件封装【只是没有像vue.js那么明显，小声逼逼，我还是爱Vue的】 参考：【非常感谢！】 react官方中文文档 react.js小书 深入浅出React和Redux]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”leetcode(1)-各种反转]]></title>
    <url>%2F2019%2F05%2F07%2F%E2%80%9Dleetcode-1-%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[Leetcode之反转 好了，从简单的开始嘛，那就从各种字符串的反转开始扒，反转呀反转转呀转呀爱的魔力转圈圈 第一道题[344. 反转字符串]原题描述如下： 思路如下： 一开始最直接的想法就是直接 return s.reverse(); 哈哈哈然而如果面试的时候是不可能这样滴； 分析一下题目的关键字眼“原地修改输入数组”，不能申请额外的空间，只能在原数组上操作 接着题目的要求是反转，简单理解就是调个头，那么就是1跟n调换，2跟n-1调换… 就其实很容易想起递归，不断地把“第一个”元素跟“最后一个”元素进行交换，递归的边界是“尾巴”在“头”前面了就停止递归； 再另外一个点就是可以利用 ES6 的“变量的解构赋值”实现交换元素，就不用再申请一个临时变量；【等我哪一天来整理一下ES6的变量解构赋值。。】 源代码如下：12345678910111213141516171819/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; // return s.reverse(); swap(0,s.length-1,s) return s;&#125;;function swap(start,end,s,)&#123; if(start &gt;= end)&#123; return &#125; // 交换元素 [s[start],s[end]]=[s[end],s[start]]; swap(start+1,end-1,s)&#125; 第二道题[557. 反转字符串中的单词 III]原题描述如下： 思路如下： 首先呢，题目的参数是字符串，那么其实一般会考虑说把字符串转化成数组，因为数组原生的方法比较多，可以直接利用数组原生的方法(等我哪一天来整理一下…妈呀希望旗子不要倒) 那么由于在字符串中单词之间是以空格隔开的，因此可以利用string.split() 这个方法传入一个空格参数，然后根据空格把字符串中的单词作为数组的一个个元素； 好了，接下来就是将数组中的每个元素[元素是个单词哦]内部的顺序调换一下就好了，调换顺序可以想到reverse()嘛 对数组的元素进行遍历的话，就可以用最原生的for呀，当然最简洁的还是用map(注意注意又是一个考点了，map，filter和reduce的区别，这个我后期一定会整理出来的)总结：emmm我觉得这道理的思路真的是很简单，但是我觉得主要考察的点还是对于数组和字符串原生方法的熟悉度，其实这个也是蛮重要的，在一些主要考思维的算法题，能够利用好一些原生的方法能节约很大的力气，而且对于空间、时间等也是有一定优势的。所以个人感觉需要透过简单题目得到启发去更熟练一下原生的方法。 源代码如下：1234567891011/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseWords = function(s) &#123; let arr = s.split(" "); let result = arr.map(item =&gt; &#123; return item.split("").reverse().join('') &#125;) return result.join(' ');&#125;; 第三道题[7. 整数反转]原题描述如下： 思路如下： 首先还是跟上一道题差不多，因为很简单，所以直接调用一些原生的方法就可以解决； 分为大的两种情况，超过32位的和没有超过的 主要是正常的没有超过32位的又可以分为＞0，＜0，还有=0；然后直接处理就好 但是我这道题跑了很多遍了还是没办法跑通所有的测试用例，卡在了32位上；还是蛮奇怪的，我还没找到原因(虽然我是用最粗暴地方法去判断2的32次方，但是也没毛病呀emmmm)总结：总的来说这道理的思路真的是很简单，同样我觉得主要考察的点还是对于数组和字符串原生方法的熟悉度，但是这道题有大数限制有边缘判断emmm是的我还不会，所以下面贴上的也是我跑不过100%的代码（后续我去找解决方法更新上）源代码如下： 123456789101112131415161718192021222324252627282930313233/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; //求绝对值 // var t = Math.abs(x); if(x&gt; 2147483647)&#123; return 0; &#125; else if(x&lt;-2147483648)&#123; return 0; &#125; else&#123; if(x &gt; 0)&#123; var a = x.toString().split("").reverse(); return Number(parseInt(a.join(''))) &#125;else if(x &lt; 0)&#123; var x = -x; var a = x.toString().split("").reverse(); var b = Number(parseInt(a.join(''))) return -b; &#125;else&#123; return 0; &#125; &#125; &#125;; 第四道题[206. 反转链表] 这道题跟剑指offer有点点不一样，剑指的感觉比较简单一点，这个感觉有点麻烦，可以用递归和迭代，晚上也是先做了一点，但是emm今晚没时间整理了，我需要早点回去睡觉所以先放个图]]></content>
      <categories>
        <category>算法打卡</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五月小记录]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BA%94%E6%9C%88%E5%B0%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[五月关键词幸运、 新生、 小记录2019/5/6(立旗子的一天) 先补一下昨天的，昨天是五一假期后的第一个工作日，日常刷着腾讯的校园招聘网，刷着刷着突然发现变成“HR面”了，感动到哭泣，虽然有点奇怪，按照之前的流程的“GM面”，后面咨询了另一个鹅厂的师兄说去年也有这样的，校招生GM面不是很多。不管结果怎么样结果还是很开心的，总算还是看到了一点点光芒，感恩。 然后就是今天一直不敢手机离身，很怕错过鹅厂突击的电话，不过还是没有等到，emmm牛客网一大堆都在HR面（手动捂脸） 接着是，今天又立了很多旗子了，一个是跟安琪打卡每日一道 Leetcode，还有每周至少一篇高质量博客输出。还有自己新申请了一个公众号，并且承诺了一定一定尽量勤奋地更新，希望自己这次要做到啊！ 2019/5/7emmm啊我今天终于去看了医生了，好的应该问题不是很大扒。每次都是自己自己吓自己呜呜呜，拿到报告的那一刹那感觉自己身患绝症（手动捂脸），回宿舍了听专业的医生煜林哥哥的解释后就安心了很多了嘤嘤嘤，但是呢呜呜呜我不想去医院鸭不想去复查，检查好难受呀嘤嘤嘤[好的，我还是会去的]。主要的原因医生说主要的原因可能还是太过于焦虑和熬夜过度，好的我接下来一定好好早睡，医生要求我十一点前睡觉，天呐我尽量吧，现在十点多了呜呜呜呜，好了我不叨叨了 最后就是打卡开始啦啦啦，我会加油的，还有要考试了。 mua，我爱我的家人我的朋友们。]]></content>
      <categories>
        <category>小记录</category>
      </categories>
      <tags>
        <tag>小记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四月小总结]]></title>
    <url>%2F2019%2F04%2F27%2F%E5%9B%9B%E6%9C%88%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[四月关键词煎熬、累、幸福、矛盾 小总结？其实倒是想不太起来一些非常印象深刻的事情了，可能还是缺少记录。我觉得适当地记录一些自己心路历程，一些想法还是挺好的。希望自己以后能够坚持着记录这个习惯。 正式总结 翻了四月份的朋友圈，好像留下的并不多，那就说一下一些比较值得说的事情吧。还有，依旧感谢身边的小伙伴海涛师兄志强师兄洁鹏安琪。。。加油啊大家！ 在一起首先，四月份，锐锐终于回学校了，我们终于结束了异地，终于了可以短暂地在一起了。这也是我一件我觉得很开心的事情了。就是那种我们不需要腻在一起，但是有在我身边就会觉得踏实的感觉，会很珍惜吧，觉得幸福。而且蛮多时候陪我在工一，我复习，他写毕设处理事情，其实呆在一起的时间就是一起去饭堂吃饭和晚上一起回宿舍的时间，还是我们一如既往地风格，平平淡淡，但是感觉还好，至少呆在一起的时候我们是开心。在这个阶段，确实我不应该放松下来，记得三月中旬的时候锐锐中途回来学校一次可以有一天陪着我不过他还是选择在咖啡厅陪我学习。怎么说呢，挺多人会觉得我们的恋爱过于平淡，主要是少了那种情侣的那种甜。作为当局者，我感受到的可能是另一种风格，就是会去实际做一些对对方好的事情，例如我需要面试的时候陪我去面试，我需要学习的时候陪我学习，很多时候还是能够感受得到的。也可以说是另一种甜吧，例如情人节的时候，他说“你找到理想的offer就是最好的礼物”，毕业的时候“你就是毕业礼物了”，给我送饮料的时候也给我身边的同学带吃的人我跟他们联络联络感情，后知后觉也发现这也是一种甜吧。蛮多细节还是挺感动的吧，感恩。 面试这个月的主旋律就是面试笔试面试笔试…从一开始面试的时候各种紧张（虽然现在也是紧张）到现在笔试面试都有点麻木了的感觉。emmm但是其实结果并没有好。准备的比较晚，确实是没办法。哎呀，其实中间还是情绪奔溃过几次的，就有点难受然后就忍不住就眼泪刷刷流下来了。呀看朋友圈记录了一下： 4月8号的时候，跟锐锐晚上回去的时候就不知道说起什么了吧，然后挺难过的看不到希望，最后走进西六的时候说了一句“我不想面试了”呜呜呜，然后一回头眼泪就刷刷地忍不住往下掉，走到天台，因为泪水模糊了眼睛，用手机拍下了还没对焦的时候的景象。挺美的吧。当时发了四张图片，每一张图片都是越来越模糊，没有配文。当时就想好累，我好想放弃了，放弃多容易，我就不用折腾了，然后哭完擦干眼泪就下去洗澡了，想想还是应该继续好好学习，放弃太没意思了。 4月10号的时候，终于开始面试了，早上面了商汤，下午面了头条，晚上笔试了腾讯了。这一天的结果都不是很好。不过就一天下来的感觉就是挺累的，还有就是还是懵懵懂懂没怎么找到面试的感觉。也是意料之中吧，万事开头难。 后面陆陆续续做了微众的笔试，阿里的笔试，面了CVTE一面，起起落落的CVTE二面。。。这期间吧，就是起起落落的感觉，然后患得患失，又像打不死的小强，被腾讯捞起来，被阿里捞起来。 19号接到腾讯电话，20号开始面腾讯一面；22号早上变为复试，22号下午接到电话，23号上午面了腾讯二面，并且当天更新了时间但是没有改变状态；就这样焦急地了几天后，终于在26号晚变了状态，但是emmm并不是HR面，是GM面，就还是特别忐忑吧，还有一轮技术面，就很悬很害怕挂了。但是能走到这么远其实还是觉得应该是挺幸运的吧，其实能一直保持下去！不管怎么样不骄不躁继续加油吧！ 远方过去的接近一个月，其实最大的问题可能还是心态方面不够好，还有在时间分配方面效率不是很好。希望自己在接下来一个月中能完成一些些小目标，每天都在超越自己，刷新自己 好好耕耘博客，每天积累一点点（算法、基础、框架） 希望自己在动手方面多一点操作。 记录一些计划和一些想法。 高效一点点。 最后附上一张傻子照片，希望能早日上岸承诺大家做的那个测评！五月加油~]]></content>
      <categories>
        <category>小记录</category>
      </categories>
      <tags>
        <tag>小记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里(2020届暑假)一面]]></title>
    <url>%2F2019%2F04%2F25%2F%E9%98%BF%E9%87%8C-2020%E5%B1%8A%E6%9A%91%E5%81%87-%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[自我介绍 有没有出去实习过（没有，那项目？在学校团队做的） 简单介绍一下项目做了什么 vue的生命周期 vuex怎么实现的（说了store、state、commit怎么触发mutation、dispatch怎么触发action…反正扣的挺细的） 问 vue router怎么实现（emmm天呐，说的不好，磕磕巴巴的，简单说了两种模式，但是一直扣细节。。。两种有什么区别之类的） 说一下异步的各种实现方式，分别有什么特点，优缺点各是什么（说了promise、generator、async和await的特点和优缺点） 说一下数组的各种方法，例如遍历的各种区别（说了forEach的特点【说到无法中断跳出循环的时候面试官加问了如果要跳出循环的话怎么实现，说了用for。。。加判断方式，不知道可不可以。。。哎】），又问了筛选过滤的话用什么方法【filter】，问了filter和reduce的区别 了解模式吗？写一个单例模式（说的磕磕巴巴，勉勉强强，最后面试官说可以了，我get到你的点了。捂脸尴尬.jpg） a标签的绝对路径和相对路径（问各个/代表的意思？没有get到点，最后直接结合情景问了页面跳转的问题） 前端请求一张图片，到显示在页面的过程（大概回答了输入URL到整个页面渲染的过程，变换一下一些细节） 前端拿到数据，对数据进行排序，再展示，怎么排序。（说了sort，如果是数字的话之间调用a-b或者b-a，但是字母的没说出来。。。只说字母是根据unicode然后emm） 有没有拿了其他offer，说了比较晚投，只投了感兴趣的，目前腾讯复试流程吧啦吧啦。差不多就是这些吧，有一两个问题不记得了。面完有点晕醉醉的想不起来。。。]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯(2020届暑假)复试面经]]></title>
    <url>%2F2019%2F04%2F24%2F%E8%85%BE%E8%AE%AF-2020%E5%B1%8A%E6%9A%91%E5%81%87-%E5%A4%8D%E8%AF%95%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[自我介绍 怎么学习前端的 开始问项目，问项目为什么要用Vue（从项目本身的特点、Vue的特点生态圈之类的以及vue的学习成本） 那横向对比其他框架为什么没用其他的（emmm由于后面项目的局限性和时间的关系，自己对其他框架了解并不是很多。。。尴尬） Vuex的特点，为什么要用vuex（妈呀终于问到自己会的了哎） Vue router的实现原理（emmm有点菜知识盲区，研究了什么数据绑定之类的但是没有研究过router，大概说了一下但是没有说到点，下去一定好好补！） 知道优化吗？（结合URL到页面加载的那个过程了列举了DNS、TCP、HTTP挨个提了大概的方法，还没说渲染部分的优化，然后面试官就开始问我前面说的了） 那你说一下DNS缓存是怎么优化的 CDN是怎么实现优化的 减少HTTP请求举一个例子（举了雪碧图的例子，然后面试又继续问了说在图片方面说还有其他减少HTTP请求的方案吗。。。当时没有想起来Base64。然后就说了其他图片的格式例如webP的优化，说着说着就想起了base64跟雪碧图是一样的道理的，然后就说，终于get到点了） 那如果从缓存方面优化有什么方式（说了HTTP缓存和memory cache） 说一下HTTP缓存的方式（说了强缓存和协商缓存，详细地再问了分别返回了什么状态码和last-modified以及Etag的区别） 再问一个状态码，301 说一下HTTP和HTTPS的区别，主要说一下HTTPS（我怀疑是不是因为我的专业是信息安全啊每个面试必问的一道题） 情景题，用微信扫描二维码登录这个过程涉及到的知识点（emmm这个有点茫然，说了一点，面试官就慢慢引导我说手机请求服务器，然后服务器再向客户端连接，服务器怎么跟客户端建立起 长 连接，我说了websocket没有get到点，想到还能长连接的就是keep-alive了吧，但是依旧没有get面试官的点，于是这道题就过了。。。） 算法题。实现两个超大整数相加 尾声：问什么时候可以去实习，可以实习多长时间 挺幸运的，没想到四月底还能收到腾讯的面试，面完官网更新了时间，但是状态还是停留在复试。希望好运，加油！]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯(2020届暑假)一面面经]]></title>
    <url>%2F2019%2F04%2F24%2F%E8%85%BE%E8%AE%AF-2020%E5%B1%8A%E6%9A%91%E5%81%87-%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[麻叶，由于之前上学期期末照顾麻麻错过考试，三月上旬才补完考试。开始春招复习，完美错过鹅厂的提前批。第一次面大厂有点紧张呀 （首先面试官小哥哥介绍了部门是腾讯云包括部门做的一些东西之类的，然后就叫我自我介绍）自我介绍吧啦吧啦 怎么学前端的（介绍了一下学前端的历程结合项目说了一下，接触新知识的途径之类的，社区，文档，阮一峰博客教程【后面被自己坑了2333。。言多必失】） 遇到问题怎么解决的，举一个例子 （举了webGL项目的跨域问题，详细说明了自己通过什么方式去解决问题的，以及最后的结果。最后总结了一下一个大致的流程【针对问题网上寻找别人的解决方案-&gt;透过问题的本质看问题的原理是什么，从根源自己去尝试解决-&gt;再跟同学、师兄们讨论问题想法之类的】） Webgl项目做了哪些优化。（吧啦吧啦由于项目本身的局限性没有太多可实施的空间吧啦吧啦，但是自己有去学习了解，例如项目的静态资源比较多，可以考虑CDN） 那你知道CDN的原理吗？吧啦吧啦说完了 CDN会把最接近用户的节点返回给用户，你知道用了什么算法吗？（黑人问号脸。。。这是知识盲区了） 刚刚你的项目说到跨域，那你们平时项目中前端自己怎么实现跨域的？（？？？平时项目前端没有实现跨域啊，好像是后台同学实现的） 那后台同学怎么实现的有跟你们前端说吗？（？？？没有啊，后台同学没说。。。。但是呢嗯，我认为他们应该是使用cors，吧啦吧啦说它有什么优势，那么常用的还有什么jaonp。。。。之类的，但是跨域这个东西还是后台设置一下会比较方便） 那你们平时项目中有考虑安全问题吗？（还真的是没有。。。因为做出来的系统是企业自己用的，但是自己会去了解一下安全的问题，介绍了一下xxs和跨站。。。） 还是项目，那你是怎么部署项目的（？？？第一个项目是师兄部署的。。。第二个项目由于自己的服务器怕不是很强所以老师部署在学校的网络中心了。。。。） 你有学习过node吗？（基本算没有吧啊。。。就是在做webgl的时候为了实现跨域自己用原生的写了一个服务器。。。。） 好，刚刚你说在本地开发的时候用了anywhere做本地服务器，那你给我介绍一下这个东西，是一个浏览器插件吗？？？（不是，不过也是一个插件吧啊？直接通过npm install anywhere安装完 再通过命令就在本地dale一个服务器了。。。。具体这个东西是什么我没有了解过，只是知道怎么用，尴尬捂脸.jpg） 项目用过vue是吧（对，吧啦吧啦出于对学习成本和项目类型的考虑什么的，决定用vue做） 那你说一下vue的双向数据绑定原理 那你知道VNode的diff吗？（嗯？我想一下，这个时候面试官提醒了标志静态节点之类的。然后就说一下大概通过静态节点优化的过程） 然后说到VNode，就开始问我说知道哪些数据结构，那么树的遍历方法（感觉完了，面试官要怼我数据结构了，说了前中后，这时候一个电话打进来，面试官去接电话了，哈哈哈哈救星） 回来面试官就没问这个问题，但是。。。他就说了ES6增加了symbol有了解过吗？（完了，看过但是不记得了，接着面试官说不是说你看过看过阮一峰的教程吗？或者你觉得增加这个原始数据类型是为了干什么？还是继续黑人问号脸，那你我知道set，the map结构对吧？知道，那你知道weakmap的差别吗？完了又不知道，然后这个问题就过了，） 那你知道display值吗？（说了4种display的值，以及非常详细的说了他们的区别，） 有了解过常用的布局方式吗？（说了传统布局弹性布局及三个布局，然后就说了这几种的差别，然后就继续问所在项目中有用过弹性布局吗？还是没有用过，但是自己会去学就有了解过这个方面的，） 然后就问了一道布局题目，给了一个场景，两行，然后左边固定宽度，右边可以自适应这样子（然后我当时我当时出于就美观问题的考虑到左边固定下来，然后右边做一个自适应，然后我说了从传统布局上去考虑。嗯，结果不是面试官想要的答案，他问了我为什么说不用刚刚说的弹性布局？然后就解释了，说是处于实际项目中，如果出于UI方面的考虑这样子） 最后在问了一道算法题，就问了数组中有k个数，从中取n个数是他的和为m（嗯，思考了一下，给出的第1个答案是说使用暴力破解的方式就直接k取n，然后再一个一个去遍历。然后再给出第2种答案，感觉可以用动态规划，于是面试官提示了说假如我就给你三个数，你要怎么解决？然后就说了说，先用两个数相加得到结果，然后再在这个结果上再进行遍历，其实就是想表达一个动态规划的过程，但是有点模糊了，然后最后直接跟面试官说，大概就是这个意思，然后面试官说嗯，行，大概知道了） 最后就是面试官说了，结果会在两天内，如果没有收到结果就，可以继续复习。感觉有点凉凉，虽然时间很长，捂脸.jpg。（不过最后还是通过了初试，感恩）]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F04%2F13%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP的特性 HTTP协议是构建于TCP/IP协议之上的一个应用层协议，默认端口是80，HTTPS是443 HTTP是无连接无状态 永远都是客户端发起请求，服务器回送相应，所以无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端；， 支持客户/服务器模式，支持基本认证和安全认证。 简单快速，请求服务时只需传送请求方法和路径，灵活，允许传输任意类型的数据对象。 HTTP0.9和1.0使用非持续连接，限制每次连接只能处理一个请求，服务器处理完客户的请求并收到客户的应答后就断开连接；HTTP1.1使用持续连接，不必为每一个Web对象创建一个新的连接，一个连接可以传输多个对象，采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议，对于事务处理没有记忆能力，缺少状态意味着后续处理前面信息需要重传，导致每次连接传送的数据量巨大。（因为服务器需要面对很多浏览器的并发访问，为了提高服务器对并发访问的处理能力。） HTTP之URLHTTP使用统一资源标识符（URI）来传输数据和建立连接，URL是一种特殊类型的URI，包含用于查找某个资源的足够的信息。URL（统一资源定位符）地址； http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 协议：HTTP 域名：www.aspxfans.com（也可以用IP地址） 端口部分： “：”隔开，不是必需的，可以是默认 虚拟目录：域名后的第一个/到最后一个 文件名：域名后的最后一个/到？或者#为止，不是必需的 锚：#开始到最后，不是必需 参数？ # 之间的那部分 URL和URI的区别： URI是统一资源标识符，用来唯一的标识一个资源（HTML、图像、视频….）。URI的组成为 访问资源的命名机制，存放资源的主机名，资源本身的名称，由路径表示并着重强调资源； URL是统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，指明了如何locate这个资源；URL由协议，IP地址，主机资源的具体地址 HTTP的请求和响应请求报文：HTTP是以ASCII码传输的。HTTP的请求分为三个部分：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 请求行：请求方法，URL，HTTP协议版本号， 请求头部：说明服务器要使用的一些附加信息 请求数据：可以添加任意的其他数据 响应消息Response状态行、消息报头、空行和响应正文 状态行：协议版本，状态码，状态消息 消息报头：用来说明客户端要使用的一些附加信息 空行 相应正文，服务器返回给客户端的文本信息 HTTP状态码 1xx：指示信息–表示请求已经接收继续处理； 2xx：成功–表示请求已被成功接收理解接受； 3xx：重定向–要完成请求必须进行更进一步的操作； 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务端错误–服务器未能实现合法的请求 常见的状态码 200 表示请求被服务器正常处理 204 表示请求已成功处理但是没有内容返回 206 服务器已经完成了部分GET请求 301 表示请求的资源永久地搬到了其他的位置 302 表示请求的资源临时搬到了其他的位置 303 表示请求资源存在另一个URI，应使用GET定向获取请求资源 304 表示客户端发送附带条件的请求（GET方法中的if…）条件不满足 400 请求报文存在语法错误或参数错误，服务器不理解 401 发送的请求需要有HTTP认证信息或者是认证失败了 403 对请求资源的访问被服务器拒绝了 404 服务器找不到你请求的资源 500 服务器请求出错 503 服务器超负载或正停机维护无法处理请求 HTTP请求方法GET、POST、PUT、HEAD、DELET、OPTIONS GET和POST的区别 由于HTML标准对HTTP协议的用法的约定，POST数据是放body,GET数据是放在URL中。但是现代的web server都支持get包含body的请求。 特定的浏览器（IE）对URL长度的限制是2083字节；理论上没有长度限制，其限制取决于操作系统的支持。URL太长对服务器处理事一种负担，处于安全稳定等方面的考虑，会给URL加长度限制，是对所有的HTTP，于get和post没关系； POST比GET安全；通过GET提交数据用户名和密码将明文出现在URL，因为登录页面可能被浏览器缓存。GET提交住居可能会造成Cross-site request forgery攻击。 GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别，上面的只是在使用上的区别。 持久连接HTTP协议采用“请求-应答”模式，当使用普通模式的时候，即请求一次就新建一个新连接，完成后就断开连接（无连接的协议）；当使用Keep-Alive模式的时候，Keep-Alive功能使客户端到服务端的连接持续有效，当出现对服务器有后继请求的时候，就可以避免建立或者重新建立连接。 在HTTP请求头中添加一个字段Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。 HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。 HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。 HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP1.1 版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连接特性，否则会有意想不到的后果。 HTTP 管线化默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3。 HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3。 会话跟踪 什么是会话？ 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。 什么是会话跟踪？ 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。 会话跟踪常用的方法: URL 重写 隐藏表单域 Cookie Session HTTPS的工作原理]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议]]></title>
    <url>%2F2019%2F04%2F13%2FTCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP的特性 TCP提供的是一种面向链接的、可靠的字节流服务； 只能用于广播和多播； 使用校验和，确认重传机制来保证传输数据的可靠性 把数据分节进行排序，保证数据的顺序不变和非重复； 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小来进行拥塞控制； 但是TCP不能保证数据一定会被对方接收到，但是她能提供数据的可靠递送和保障的可靠通知。 基于TCP的应用层协议还有HTTP，SMTP，FTP，Telnet和POP3 三次握手所谓三次握手，就是指在建立一个TCP连接时，需要客户端和服务器总共发送3个包；目的是连接服务器的指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。 第一次握手（SYN=1；seq=x）：客户端发送一个TCP的SYN标志位置1的包，指明客户端打算连接的服务器的端口，初始序号X保存在包头的序列号字段里；（SYN_send） 第二次握手（SYN=1；ACK=1；seq=y，ack=x+1）：服务器发回确认包（ACK）应答，即SYN和ACK都为1；服务器选择自己的ISN序列号放到Saq域里，同时将确认序号设置为客户的ISN+1，发送完毕后进入SYN_RCVD状态； 第三次握手（ACK=1，ack=y+1）：客户端再次发送确认包（ACK），SYN标志位为0；ACK为1，把服务器发来的ACK序号字段+1放在确定字段中发送给对方，并且在数据段放写ISN的+1； 为什么要进行三次握手 首先3次握手完成了两个重要的功能，双方做好发送数据的准备工作，和允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认； 那么如果改成两次握手，死锁是可能发生的，例如在计算机C和S的通信中，C给S发送一个连接请求，S收到了请求并发送确认应答分组，如果是两次握手协议的话，那么S就会认为已经成功建立连接了可以开始发送数据分组了，、。可是，如果S的应答分组在传输中被丢失的情况下，C就不知道S是否准备好，会认为连接还没建立成功，会忽略S发来的任何数据分组，只等待连接确认应答分组，而S在发出的分组超时后会重复发生同样的分组，这样就形成了死锁。 四次挥手 第一次挥手（FIN=1，seq=x）：假如客户端想要关闭连接，就会发送一个FIN标志位置为1的包，表示自己没有数据可以发送但是可以接受数据；FIN_WAIT_1 第二次挥手（FIN=1，ack=x+1）：服务器确认客户端的FIN包，并发送一个确认包，表明自己接受了客户端的关闭请求连接但还没准备好关闭连接。发送完毕后，服务器就进入CLOSE_WAIT, 而客户端接收到这个确认包后就进入 FIN_WAIT_2状态，等待服务器关闭连接。 第三次挥手（FIN=1，Seq=y）：服务器准备好关闭连接时，向客户端发送结束连接请求，FIN置为1，发送完毕后，服务端就进入LAST_ACk状态，等待客户端的最后一个ACK； 第四次挥手（ACk=1，ack=y+1）：客户端接收到来自服务器的关闭请求，发送一个确认包，并进入TIME_WAIT 状态，等待可能出现的要求重传的ACK包；服务器接到这个确认包后就关闭连接进入CLOSED状态。客户端等待某个固定的时间段（两个最大段生命周期）之后没有收到服务器的ACK，就认为服务器已经正常关闭连接，于是自己也关闭进入CLOSED状态。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先生与夫人]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%85%88%E7%94%9F%E4%B8%8E%E5%A4%AB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[妈呀。这是一篇不好意思写下去博客。还是算了算了。等我春招再来好好写写。]]></content>
      <categories>
        <category>小记录</category>
      </categories>
      <tags>
        <tag>小记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面优化]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[页面优化1. 卡顿 减少 layout，减少页面重绘。能用 transform ，就不用 position/width 。。；减少layout 的影响范围 简化 DOM 结构。使用flex 比使用 float 在重绘方面有优势 2. 加快页面的打开速度 避免 head 标签中的 js 阻塞。head 标签中的外链脚本会影响 DOM 构建和页面图片的加载。可以放在 body 后面，或者加上 defer 属性延后异步加载，不会造成阻塞，但是异步加载可能会影响交互的效果。 减少 head 标签中的 CSS资源。由于 CSS 必须放在 head 标签里面，如果放在 body 里面，一旦加载完了，就需要对 layout 好的 DOM重绘，导致样式可能发生闪烁。如果资源过多加载过久会使页面造成空白。另外，可以把部分 CSS 变成内联。 优化图片 使用响应式图片； 延迟加载图片，渲染页面时图片地址放到 src 上，发到一个 data 的属性中，src 设为 about ： blank，根据位置判断，监听 scroll 事件， 压缩和缓存 gzip压缩，在 Nginx 的配置中添加这个选项。 Last-Modified 字段进行比较，返回 304 还是 200； 手动控制缓存 Cache-Control etag ,对文件做的一个检验和， HTTP/2 对于一个域 只建立一次 TCP 连接，使用多路复用，传输多个资源 其他优化方案 DNS 预读取 HTML 优化 代码优化。嵌套加重 layout 压力。选择器别太复杂，滥用闭包加深作用域链加长变量查找时间。 3. 增强用户体验 加 Loading 效果 加过渡动画效果 transform + width 单击和输入 按钮提交有一种按下去的效果，设置 padding-top 和深一点的背景色 input 的 type 属性，移动端对应不同的键盘； 记住用户的习惯 记住位置，页面大小，可以使用 本地存储解决或者使用 cookie，刷新时自动获取本地存储里的 key 值 记住用户的输入信息 避免页面闪动]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记录]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%B0%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录想要记录一下这段时间的心路历程。也当做给自己的一些鼓励吧~【想起来就写几句】 4.26 寻寻觅觅觅觅寻寻今晚，等了好多天腾讯终于终于变状态了！然而变的是GM面emmm听说是大佬面，挺虚的吧其实，还记得上周六被CVTE的大佬怼技术细节怼的无话可说，还是挺菜的。所以面对这次的又一轮技术面还是挺虚的。求好运吧，加油啊！！！还有今晚面了通联的二面，还行都是偏基础问题也不问的很深，自我感觉还可以不过还没结果。真的是很希望最后一面技术面能让我顺顺利利的让我结束这段春招吧！后面我一定会好好学习的嘤嘤嘤！加油呜呜呜 4.25 大概时光也不负有心人吧今天确实蛮累的了，跟某某鹏吐槽说，前期可能是心累，到了后期身体也挺累的，主要是睡眠质量太差。面了大大小小也挺多面了，今天面阿里昨晚蛮紧张的，就睡的不太好，早上十点开始面试所以还是挺早过来准备。面完阿里中午又意外接到另外一个公司（通联，好像是一个在金融方面蛮强的公司？）的面试电话。原定十五分钟最后扯了大概四十分钟顺便约了二面，聊完教工堂没饭吃了…再下午在办公室接到高新兴的面试邀请，综合考虑还是选择去试试吧虽然真的是好远呀想到还是觉得有点累，看样子我大概28号又要旷马克思了。感慨一下，面试真的是一个综合实力的考察吧，除了实实在在的硬实力（菜真的是原罪啊），性格呀给人的感觉，沟通的过程呀，还有运气呀我真的是也很想有运气。四月底，算从考完试结束，我真正投入春招的时间也一个多月了，时间真的是过得太快太快了，哇可是想抓住春招的尾巴~最近呀，虽然各种被虐不过其实幸福感也不算低，挺多时候还是蛮开心的，就很累但是因为大家都一样这个阶段早晚都要经历，而我感觉提前做好准备总是没错的，最主要可能还是因为一直有人陪着吧，虽然说真正撑起自己的永远是自己。四月最后的，再次集集一波好运气，希望腾讯的复试不要卡太久，然后其他的也能顺顺利利的。继续努力鸭，好了我决定今晚要早早回去洗澡然后去床上躺着了。 4.24 星光不问赶路人妈呀说好的小记录说着都没更了。 这两天有点低效，有点浮躁，随着四月底了，但是还没拿到满意的offer，春招快结束，还是特别捉急的。 但是好像也在慢慢转运啦。继续努力啦，接下来就交给运气啦。希望腾讯顺顺利利拿到offer，明天的阿里也顺顺利利的。 3.2这几天由于电脑出问题了，也几天没有更新。 今晚呢，跟师弟们对接了挑战杯项目的东西了，也算是为团队再做一点自己力所能及的事情吧，说起来还是有点愧疚的，但确实也是没有办法的事情，接下来可以安安心心地按照计划行事了。 上一次情绪波动比较大是26号，刚好看到了上面的记录。这几天由于电脑的问题，非常担心进度受到了影响，因为这个时候本身时间就非常短。到了昨晚，情绪非常不好，还总结了五点不开心的原因发给了锐锐，风格一下子的转变可能吓到锐锐了，他好像担心我了担心三月的事情是不是压的我没信心了。确实这阵子事情非常非常多而且没有安排好导致自己很多时候都不知所措。 一番倾诉和交谈过后，也慢慢地找到了问题所在也确立计划。好像感觉前进的道路不是那么顺利挺多阻碍，但是很感激一直都有人关心有人了解，谢谢锐锐、同桌、晓敏、tmk…很感激在我每一次觉得不是很开心的时候能听我倾诉，主动的关心；感谢同行的小安琪、杨艺加油哦！感谢海涛师兄每次非常耐心地指导技术问题。每次遇到挫折困难的时候总是感觉自己想得到东西老天总是费尽心思地在阻止我，但是一想到身边那么多人非常真心地陪伴着，内心也多一丝暖阳和一股勇气。早上睡醒答应自己也答应锐锐，遇到问题的时候先冷静地调节一下，做好计划并且坚持下去。这阵子越来越觉得锐锐可能是最了解我的人了，超过了我的同桌和认识了十多年的蜜蜜可，往往能了解我最直接的需要和问题的本源所在以及性格的深处，这阵子大概最感激的人就是锐锐了，很辛苦地照顾着情绪多变的我，在我这段最艰难的时间里陪伴着我，遇到你是我最大的锐锐。 好了最后，我向你们承认自己的错误，我不应该在还没开始尝试的之前一直贬低自己说自己找不到了说自己不行，其实是害怕你们最后失望了，但是我保证我不会再说了，我会加油的。爱你们哦，晚安么么！ 2.26今天是网申了 CVTE，正式地开启了自己的春招之旅。 下午师兄来谈了挑战杯的事情，有点感觉自己快被压倒了，因为没办法兼顾那么多东西了。这种奔溃的感觉持续了大概三个小时，慢慢地还是调整了过来。 有一些东西还是要舍弃的。每个阶段会有每个阶段的重点。 今晚看到一句话：最高境界的善良就是学会共情。可是有时候共情这个东西给我带来很多多余的烦恼，虽然也给我带来一些收获，也许确实凡事要有个度，只是大概那个度太难把握了。 嘤嘤嘤最后，好感动呀！被师弟们感动到了，都是一些什么宝藏师弟鸭，真的是何德何能对我这么好。 2.25今天是开学的第一天，我大三下了。早上是开开心心的，随后到教室周围几个考研的同学讨论起来目标学校，突然又想起了自己的春招，有那么一点点焦虑。惊讶地发现，出于各种各样的原因好像身边蛮多人考研了，不过我还是没有动摇。 今天白天的整体状态还是蛮好的，遇到了几个老师其中知道我需要补考五门科目的时候 都很 nice鼓励我，跟我说撑过这段时间就可以了，心真的特别暖。很感激吧。 晚上回到了实验室学习，想要还是规划一下复习计划，大概看一下需要复习的东西，由于信息安全书实在是太厚，老师给的重点也很少，很慌地找了粤轩和小安琪，粤轩很耐心跟我说她记得的东西，小安琪原来不是选这门课的，本来不抱希望了，但是她后来去找了一份写满一页纸的重点来给我，我真的是那一瞬间特别感动，因为没想到只是自己抱着试一下的心态求助竟然得到别人的重视，不知道怎么说，就真的是除了感动还是感动本身，感觉自己一路都很幸运，身边的人都特别 nice，突然感觉好像大家都在帮助我，我自己应该更努力一点。【这是21:25 的心路历程】 总体来说比较积极向上的，不过还是有点焦虑，之前因为回家照顾麻麻落下的五门课缓考还是感觉有点多，春招也已经迫在眉睫了。 然而急也没有用鸭，还是一步一步按计划来扒。记起一句话：念念不忘，必有回响，你很想实现的梦想，全世界都会帮你实现…加油呀小燕子 【可能是第一次记录有点唠叨】]]></content>
      <categories>
        <category>小记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>心路历程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝和浅拷贝]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[引言在实际编程中，我们都存在着一种“复制”的现象，对 对象的复制，对数据的复制…那么就来看看在 JavaScript 中复制到底还有着什么样的秘密，这个“=”真的有那么简单吗？ JavaScript 中对象分为基本类型和复合（引用）类型，基本类型存放在栈内存，复合（引用）类型存放在堆内存。【这里建议如果不熟悉 栈内存和堆内存的区别 先熟悉一下会比较理解点】 浅拷贝和深拷贝深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。 深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，因此不会影响原来的对象。 浅拷贝仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。 例子例子 112345var a=123;var b=a;a=123456;alert(a); //123456alert(b); //123 对基本类型的操作，直接复制了对象的值，并在栈中占了一个新的空间，在这里可以联想到栈是一个后进先出的数据结构，那么理所当然读取到的也会是最后一次的 a 的值。 例子 212345var arr1=[1,2,3];var arr2=arr1;arr1.push(4);alert(arr1); //1234alert(arr2); //1234 而对于堆中的对象，复制的实质是“复制了该对象在栈中的地址” 因为 JavaScript 其实是无法操作堆中的东西滴，只能对栈内存进行操作，那么假如原对象改变了，由于指向的地址还是对象那个堆地址，所以对应的复制出来的对象也会相应改变，这即是“浅复制”【简单理解即只复制了指向的地址而已】]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈内存和堆内存]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[引言JavaScript 中的变量分为 基本类型 和 引用类型。基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。 基本类型JavaScript 中的基本类型有 Undefined、Null、Boolean、Number 和String，这些类型占有固定大小的空间（而且不大），因此我们可以把他们放在 栈内存，并直接通过值来访问。 引用类型由于引用类型的大小不固定，而且很多时候占用的内存相比较于基本类型大，那么它就适合放在 堆内存中啦！（因为堆字嘛，理所当然，从字面就可以感知到 “乱[大小不固定] 、大”，个人理解哈），但是请记住这样一句话非常重要“JavaScript 不允许去直接使用堆内存”。好，那么问题来了，放在堆里的对象我们得怎么操作。实际上是这样的，在栈内存中会放着 引用类型放在堆中 的那个位置，那么这样就可以通过栈的地址找到堆里面存放着的引用类型啦。 这样是不是很好理解一点呢 栈内存和堆内存栈内存JavaScript 中的栈内存 存放着基本类型和引用类型在堆中对应的地址。基本类型在当前执行环境结束时销毁。 堆内存JavaScript 中的堆内存 存放着引用类型，但其地址放在栈内存中，通过访问栈内存中的内存地址在堆中找到对象，引用类型不会随执行环境结束而销毁，，只有当所有引用它 的变量不存在时这个对象才被垃圾回收机制回收。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 之 BFC]]></title>
    <url>%2F2019%2F02%2F24%2FCSS-%E4%B9%8B-BFC%2F</url>
    <content type="text"><![CDATA[BFC何为 BFC 块格式化上下文 （Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 FC 是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。 如何触发 BFC 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 BFC 的规则 属于同一个 BFC 的两个相邻 Box 垂直排列 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外) BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 文字层不会被浮动层覆盖，环绕于周围 BFC 的应用 阻止margin重叠 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中) 自适应两栏布局 可以阻止元素被浮动元素覆盖]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础（三）闭包]]></title>
    <url>%2F2019%2F01%2F16%2FJavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 闭包的定义当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。 例子112345678910111213function a () &#123; function b() &#123; var bbb = 234; document.write(aaa); &#125; var aaa = 123; return b;&#125;var glob = 100;var demo =a(); demo(); 分析如下： 首先定义函数a a的作用域链为GO； a被执行，进而函数b被定义，b此时的作用域链式啊执行时的作用域链即 AO-&gt;GO,但是函数b始终还没被执行，直到a执行结束时，b才被保存到外部，demo存的的值即是b； 执行demo即执行b,此刻b的作用域链即b自己的AO+b被定义时的环境（AO【此AO为a的AO】+GO） 由此可以看出，a执行完即a的AO理应当被销毁，但是由于b被保存在外部，而b的作用域链中本身就含有a的AO，也就是所说的原有的作用域链还在被占有没有释放，由此会造成内存泄漏； 例子21234567891011121314function test() &#123; var arr = []; for(var i = 0;i &lt; 10;i++) &#123; arr[i] = function () &#123; document.write(i+' '); &#125; &#125; return arr&#125;var myArr = test();for(var j = 0;j &lt; 10;j++) &#123; myArr[j]();&#125; 结果如下： 2. 闭包的作用 实现公有变量（eg：函数累加器） 12345678910111213function a () &#123; var num = 100 function b() &#123; num ++ console.log('num') &#125; return b;&#125;var demo =a();demo(); //101demo(); //102demo(); //103demo(); //104 可以做缓存（存储结构） 12345678910111213141516function eater () &#123; var food = ''; var abj = &#123; eat : function ()&#123; console.log('I am eating' + food); food = ''; &#125;, push : function (myfood) &#123; food = myfood; &#125; &#125; return ob; &#125; var eater1 =eater(); eater1.push(apple); eater1.eat(); //I am eating apple 3. 立即执行函数在实际的应用过程中，有一些函数我们只需要用一次，执行完就不需要了，那么在这里我们可以使用立即执行函数；执行完就被销毁，不再占用空间，但是会执行一次。 1234(function a ()&#123; var a =123; console.log(a); &#125;()) 执行结果如图： 跟一般函数的区别： 形式上不一样，立即执行函数为 ( function(){}() ); 立即执行函数执行完立即被销毁； 其他没什么差别，也可以有函数名，参数，有返回值等； 4. 用立即执行函数解决闭包问题12345678910111213141516function test() &#123; var arr = []; for(var i = 0;i &lt; 10;i++) &#123; (function (j) &#123; arr[j] = function () &#123; document.write(j+' '); &#125; &#125;(i)) &#125; return arr&#125;var myArr = test();for(var j = 0;j &lt; 10;j++) &#123; myArr[j]();&#125; 结果如下：由于for循环里面采用了立即执行函数，立即执行函数的形参为j，实参为i。所以i会及时把值传给j，函数打印的是j的值了，而不再是i，因此最后结果是0123456789.然而如果打印最后i的值，还是10.]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础（二）作用域]]></title>
    <url>%2F2019%2F01%2F14%2FJavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一、何为作用域？ 如我们所知的，JavaScript 的函数是一个对象，那么既然是一个对象，就会有属性，然而对象中有一些属性我们可以访问有一些却是我们访问不了的，访问不了的那些是JavaScript引擎存取的，那么我们的作用域[[scope]]就是其中一个。作用域[[scope]]存储了运行期上下文的集合。 那么问题又来了，执行期上下文又是什么呢，就是当函数执行时，会创建一个称为执行期上下文的内部对象，一个执行上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文是独一无二的，并且当函数执行结束时，它所产生的执行期上下文会被销毁。 接着说到作用域，那也要说一下作用域链，作用域[[scope]]中存储的执行期上下文对象的集合呈链式链接，所以叫作用域链。 那么我们查找变量就是从函数作用域链的顶端依次向下查找二、结合例子讲解 1234567891011121314function a () &#123; var aa = 2; function b () &#123; var aa = 3; function c () &#123; &#125; c(); &#125; b(); console.log(aa);&#125;a(); 首先 a函数被 defined，所以自然就产生了它的属性[[scope]],[[scope]]里面存的是作用域链，作用域链自然就是对象的集合，所以此时a在被定义时的作用域链就是此时的所处的执行期上下文，那么这个环境就是全局对象，因此我们的作用域链中仅有一位[0]位– global object（下面简称GO）【因为函数a刚在全局中被定义，那它的执行期上下文自然只有一个全局的对象】具体可看图一： 接着就是a函数执行，a函数执行，一个函数执行必然产生一个函数独一无二的执行期上下文即产生属于a的AO（acitive object），那么这个AO就是放在作用域链的最顶端（任何环境的作用域链的最顶端一定是该环境下的AO）。所以把AO放在顶端【0】位，那么原来的在第一位的GO就放在第二位，作用域链如图二所示： 在a函数执行的中，b被定义，因此b的作用域就是此时所处的环境的执行上下文，即函数a的作用域链，即图二所示； 接着b执行，产生自己的执行期上下文，b的AO放在作用域的最顶端，所以此刻b的作用域链即首位[0]–b的AO+b被定义时所处的环境，如图三所示： 再接着c被定义(同理)，c被执行（也同理） 最后打印出来的aa的值为3；因为b函数执行的作用域链中a的AO跟原本a函数执行的AO是同一个； 当函数执行结束时，其执行期上下文会被立即销毁，例如b执行完后，那么b的AO会被销毁，但由于a函数还没执行结束，所以a的AO还继续存在。 当再次调用函数a时，将产生新的作用域链，与之前的是否调用执行没有关系。]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础（一）预编译]]></title>
    <url>%2F2019%2F01%2F13%2FJavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E9%A2%84%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[JavaScript（一）预编译1. 关于JavaScript众所周知 JavaScript 是一门脚本语言，为了缩短传统的“编写、编译、链接、运行”过程而创建的计算机编程语言。一个脚本是通常是解释运行而非编译，因此 JavaScript 也是一门解释性语言，即解释一行执行一行。 JavaScript执行的三部曲 语法分析 预编译 解释执行 语法分析：即先通篇检查有没有语法错误，若出现语法错误，即该模块无法执行； 解释执行：即执行代码； 预编译： 可以理解为在函数执行前在内存空间开辟一些空间，存放一些变量和函数；理解了预编译能够加深对作用域的理解； 2. 预编译2.1 预编译的前奏 imply global 暗示全局变量：即任何变量，如果变量未经声明，就赋值，此变量就为全局对象所有。 12a = 123；var a = b = 123； // b未经声明就被赋值为123； 一切声明的全局变量，全是 window 的属性； window就是全局的域 2.2 预编译的四个步骤 创建 AO （Activation Object 即执行期上下文） 对象； 找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined； 将实参值和形参统一； 在函数体里面找函数声明，值赋予函数体；例如： 12345678910111213141516function fn (a) &#123; console.log(a);//a1 var a = 123; console.log(a);//a2 function a () &#123;&#125;//函数声明 console.log(a)//a3 var b = function () &#123;&#125;//函数表达式 console.log(b) function d () &#123;&#125; &#125; fn(1) 解析如下：1. 预编译过程： 创建 AO 对象 找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined； 1234AO&#123; a : undefined， b : undefined，&#125; 将实参和形参相统一 1234AO&#123; a : 1, b : undefined，&#125; 在函数体里面找函数声明，值赋予函数体； 12345AO&#123; a : function a () &#123;&#125;, b : undefined, d : function d () &#123;&#125;,&#125; 执行函数 2. 执行函数 首先打印a，在AO对象中寻找a，所以a1为function a () {} 执行 var a = 123；不完全执行，因为在步骤二中找变量声明，已经把变量提升了，但是a = 123；还没读，所以继续在 AO 对象中寻找属性名 a ，并执行 a = 123，将 a 的值 赋值为123；AO变为： 1234AO&#123; a : 123, ....&#125; 因此打印出来的 a，即 a2 为 123； 函数声明已经变量提升了；a3为123； 执行 1b = function () &#123;&#125; ,所以 b 为function () {}]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之变量的解构和解析]]></title>
    <url>%2F2018%2F10%2F24%2FES6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E5%92%8C%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、数组的解构赋值 基本用法按照一定的模式，从数组和对象中提取值，对变量进行赋值。 1let [a,b,c] = [1,2,2]; 如果解构不成功就是 undefine，如下就是解构不成功的； 12let [a] =[];let [a,b] = [2]; 如果等号右边不是数组将会报错，如下： 12let [a] = 1;let [a] = null; 2、对象的解构赋值数组的元素是按次序排列的，变量的取值是由他的位置决定的；而对象的属性是没有次序的，变量名必须与属性同名才能取到正确值。解构也可以用于嵌套解构的对象。 1let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 如果解构失败，变量的值等于 undefined。 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错 3、字符串的解构赋值1const [a, b, c, d, e] = &apos;hello&apos;; 4、函数参数的解构赋值12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 1[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); 5、用途（1）交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; （2）从函数返回多个值12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义方便将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] （5）遍历 Map 结构任何部署了 Iterator 接口的对象，都可以用 for … of 循环遍历。Map结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值很方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world （6）输入模块的指定方法加载模块时，往往需要指定输入哪些方法，解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 备注：阮一峰老师《ESMAScript 6 入门》学习笔记，很多详细内容请参考：http://es6.ruanyifeng.com/#docs/destructuring]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之let和const命令总结]]></title>
    <url>%2F2018%2F10%2F23%2FES6%E4%B9%8Blet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、 let 命令 1.1基本用法用来声明变量，但是声明的变量只在 let 命令所在的的代码块内有效。 for 循环的计数器，很适合用 let 命令。 for 循环设置循环变量的那部分是一个父作用域，而循环内部是一个单独的子作用域 1.2不存在变量提升var 命令会发生变量提升，变量可以在声明之前使用，值为 undefine1.3暂时性死区只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和使用该变量。1.4不允许重复声明let不允许在相同作用域内重复声明同一个变量。因此不能再函数内部重新声明参数。2、块级作用域 ==全局作用域和函数作用域下== 变量提升，内层变量可能覆盖外层变量。 用来计数的循环变量泄漏为全局变量。 ==ES6== 外层代码块不受内层代码块的影响。 允许块级作用域的任意嵌套，外层作用域无法读取内层作用域的变量。 内层作用域可以定义外层作用域的同名变量。 ==块级作用域与函数声明== 允许在块级作用域之中声明函数。块级作用域之中，函数声明语句的行为类似 let ，在块级作用域之外不可引见。但是幻术声明类似 var ，即会提升到全局作用域或函数作用域的头部，还会提升到所在的块级作用域的头部。 避免在块级作用域内声明函数，如果需要应该写成函数表达式，而不是含税声明语句。3、const 命令3.1 基本用法 const 声明一个只读的常量 只声明不赋值会报错。只在声明所在的块级作用域有效，存在暂时性死区，只能自声明的位置后使用。 不可重复使用。 const是指变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值）值就保存在变量所指向的那个内存地址；而对于复合型的数据（对象和数组），变量指向的内存地址保存的只是一个指针。const只能保证这个指针是固定的。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScript中函数的总结]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[函数的定义1.直接定义1234567function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 函数内部的语句在执行是，一旦执行到return时就执行完毕并将结果返回。如果没有return语句，函数执行完毕后也会返回结果，只是结果是undefined。 由于函数是一个对象，所以函数名可以视为指向该函数的变量。函数名可以保存在变量，对象，数组中。 函数还可以被当做参数传递给其他函数，函数也可以返回函数，函数拥有方法。 2.声明式定义1234567var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 将匿名函数赋值给了变量，通过变量可以调用该函数。 函数的调用调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明的参数，函数还接收两个参数this和arguments。【this的值取决于函数的调用模式】 函数的调用模式 方法调用 函数调用 构造器调用 apply调用 1.方法调用模式当函数保存为对象的一个属性时，称为方法，当方法被调用是，this绑定到该对象。该方法可以用this来访问自己所属的对象，所以能从对象中取值或对对象进行修改。通过this取得他们所属对象的上下文的方法称为公共方法。 2.函数模式的调用当函数不是一个对象的属性时就是被当做一个函数来调用，this被绑定到全局。解决方案：在函数内把this赋值给变量that 3.构造器模式如果函数前面带上new调用，会创建一个连接到该函数prototype成员的新对象，this会被绑定到这个新对象上 4.Apply调用apply构建一个参数数组传递给调用函数，apply方法接收两个参数，第一个是绑定this的值，第二个是参数数组，可以自己选择this的值 调用函数时，按顺序传入参数即可，由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有关系，虽然函数内部并不需要这些参数；传入的参数比定义的少也没有问题，但由于收到的参数为undefined，计算结果为NaN，要避免收到undefined，可以对参数进行检查。 argumentsarguments只在函数内部起作用，并且永远执行当前函数的调用者传入的所有参数，类似Array，拥有length属性。 返回当函数结束时，会把控制权交给调用该函数的程序。return语句使函数提前返回，当return被执行时，函数立即返回而不再执行余下的语句。一个函数总会返回一个值，如果没有就默认返回undefined。如果函数调用是在前面加上new，且返回值不是一个对象，则返回this 异常利用arguments可以获得调用者传入的所有参数，即使函数不定义参数，也可以拿到参数的值；而实际上arguments最常用语判断传入参数的个数 rest参数]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域的理解和解决方案总结]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[何为跨域？首先，我们得先理解一下何为跨域？所谓跨域，即网站的协议名 protocol（例如 http ://） 、域名 host （例如：www.example.com）、端口号 port (例如 80 ，默认端口可以省略) 这三个中的任意一个不同，网站之间的数据传输或者请求就属于跨域请求了。 这是由于浏览器的同源策略，为了防范跨站脚本的攻击，禁止客户端脚本对不同域的服务进行跨站调用，但是跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但返回结果被浏览器拦截了。有些浏览器不允许从HTTPS协议的域 跨域访问 HTTP协议，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。如果是非同源，共有三种行为受到限制：（1）cookie、LocalStorage 和 IndexDB 无法读取；（2）DOM 无法获得；（3）AJAX请求不能发送。【这里再解释一下同源（具体定义可以查看 MDN），如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。IE 有例外，一是授信范围：两个相互之间高度互信的域名，不遵守同源策略的限制；二是端口：IE 未将端口号加入到同源策略的组成成分中。更多有关源的介绍可以查看 MDN ：https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy】 如何去解决？ 接着，既然我们知道了何为跨域，跨越有时候在实际的开发中有时候又无法避免，下面介绍几种常见的跨域方法： 1、利用 JSONP 实现跨域JSONP （JSON with Padding）是 JSON 的一种“使用模式”。利用 JSON 实现跨域的原理是：HTML 的 script 标签是不受同源策略的限制的，可以通过 script 标签加载并执行其他的域的 js 文件的。 例如通过 jQery 封装的方法可以很方便地进行 JSONP 的操作： 12345678910111213141516171819$.ajax(&#123; type: &apos;GET&apos;, url: &apos;http://jjjjjjjj.com/data&apos;, // 需要提交给服务端的数据: data: &#123; name: &apos;燕子&apos; &#125;, // 指定数据类型: dataType: &apos;jsonp&apos;, timeout: 300, success: function(data)&#123; this.append(data.project.html) &#125;, error: function(xhr, type)&#123; alert(&apos;数据获取失败！&apos;) &#125;&#125;)//使用$.getJSON$.getJSON(&apos;http://jjjjjjjj.com/data?callback=?,function(data)&apos;)&#123; //处理获得的json数据&#125;); 总结：JSONP 的兼容性好，在更古老的浏览器都可以运行，不需要 XMLHTTPRequest 或 ActiveX 的支持，并且在请求完毕后可以通过调用 callback 的方式回传结果；然而缺点是，它只支持 GET 请求 而不支持 POST 等其他类型的 HTTP 请求；还有 只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面的之间 JavaScript 调用的问题； 2、利用 CORS 实现跨域CORS （Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的思想是使用自定义的 HTTP 头部，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源，从而决定请求或响应是应该成功还是失败，CORS 本身并非绝对的安全，可利用 OAuth2 加强保障。（更多关于 CORS 的详解可以查看 阮一峰老师的一篇文章：跨域资源共享 CORS 详解） 1header(&quot;Access-Control-Allow-Origin: *&quot;) //“*”号表示允许任何域向我们的服务端提交请求 1header(&quot;Access-Control-Allow-Origin: http://jjjjj.jd.com&quot;) //也可以设置指定的域名 与 JSONP 相比，CORS 更为先进、方便： CORS 支持所有类型的 HTTP 请求； 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理； 绝大多数现代浏览器都已经支持了CORS； 3、window.name当window 的 loaction 变化时，页面重新加载，它的 name 属性可以依然保持不变。每个页面的对 window.name 都有读写权限，window.name 是持久存在一个窗口载入过所有页面中的。 我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。 4、document.domain 跨域（只适用于不同子域的框架间的交互）同源策略不能用 ajax 方法去请求不同源的文档，还有一个限制就是浏览器不同域的框架之间不能进行 JS 的交互操作的，不同的框架可以获取 window 对象，但无法获取相应的属性和方法。 这个时候，我们可以通过把两个页面的 document.domain 都设成相同的域名就可以，不过 window.domain 的设置也是有限制的，只能把 window.domain 设置成自身或更高一级的父域，且主域必须相同 5、HTML5 的 postMessage 方法高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。 window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后（例如：在该方法之后设置的事件、之前设置的timeout 事件）向目标窗口派发一个 MessageEvent 消息。 该 MessageEvent 消息有四个属性需要注意： message 属性表示该 message 的类型； data 属性为 window.postMessage 的第一个参数；origin 属性表示调用 window.postMessage() 方法时调用页面的当前状态； source 属性记录调用 window.postMessage() 方法的窗口信息。 详细语法可参考 MDN 文档：window.postMessage]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《谁动了我的奶酪》]]></title>
    <url>%2F2018%2F10%2F19%2F%E3%80%8A%E8%B0%81%E5%8A%A8%E4%BA%86%E6%88%91%E7%9A%84%E5%A5%B6%E9%85%AA%E3%80%8B%2F</url>
    <content type="text"><![CDATA[这是2018年读的第一本书，这本书并不厚，讲的是一个简单的小故事，其中的道理更是非常地浅显易懂，道理大家都是懂的，关键是在于能否对道理深刻理解，我觉得人们所说的经验其实就是对这些简单道理的自己的深刻理解，并且只有自己经历才能真正的感受到它的作用。 这篇故事的大概是讲有两只老鼠和两个小矮人哼哼、唧唧住在迷宫中，他们以寻找迷宫里的奶酪为食物，迷宫的一些角落中往往都会藏着奶酪，那便是他们的赖以生存的食物。小老鼠的头脑比较简单，小矮人们总是认为自己比小老鼠们聪明，小老鼠就知道埋头找奶酪而已，并不会思考也不会寻找捷径。每天早上他们都会准备好装备从家里出发，一头钻进迷宫中寻找奶酪，就这样一天重复着一天，直到有一天，他们同时在迷宫的一个角落中找到了一大堆奶酪，特别特别地多特别特别地美味，他们都高兴极了，便开始习惯了每天早上不再去寻找，只要去到一个熟悉的地方就可以尽情地享受到美味，这样的日复一日，直到最后奶酪其实慢慢地变味了也变得很少了，当小老鼠发现这一切时，他们简单地只有一个想法——那就是继续去别的地方寻找可以吃的奶酪；而对于自认为头脑聪明的小矮人，他们就难以接受这个现实，他们已经习惯了不再寻找就有美味存在，他们坚信那里还有奶酪的，所以他们一直等待着，而小老鼠还是像以前一样每天都继续去寻找新的奶酪。 哼哼唧唧他们每天都去之前的地方痛苦的等待着，然而什么都没有，知道有一天唧唧想起以前每天都要去寻找奶酪，但是每天都还是可以填饱肚子的，所以他决定去试一下像以前那样子去寻找奶酪，而固执的哼哼还是想要在原地等待，他不相信奶酪会这样没了。而奔跑起来的唧唧渐渐地还是像以前一样能填饱肚子，然而哼哼仍然在原地，唧唧曾鼓励过哼哼，哼哼也慢慢地动起身来，但是他还是不相信，最后哼哼能否找到奶酪是留白的。 故事的内容基本就是以上吧，是以童话的形式呈现，虽然有点夸张，似于艺术来源于生活却又高于生活一样。书中的道理可以归结为以下： 变化总是会发生，你唯有可以做到的就是拥抱变化； 奶酪是会一点一点减少直到没有的，所以要时刻做好失去奶酪的准备； 经常嗅一嗅奶酪，这样你才会知道它是否依旧新鲜； 迅速适应变化，越快放弃变质的奶酪，你就越早享用新鲜的奶酪； 享受变化，享受探险的过程和新奶酪的美味。 书里只是反应了一定的现实。就像作者所说的那样“本书最有价值的不是故事本身，而是大家对它的理解与应用”。正所谓一千个读者就有一千个哈姆雷特，谁又能想到此书还曾经治愈过一个曾经情绪极为不稳定的少女。其实一本书、一句话只是一个契机，引发你去思考，真正做决定的依然是你的大脑。]]></content>
      <categories>
        <category>小记录</category>
      </categories>
      <tags>
        <tag>生活的点点滴滴</tag>
        <tag>书评</tag>
      </tags>
  </entry>
</search>
